<!DOCTYPE html>
<html>
<head>
    <title>ë°”ë‚˜ë‚˜ íˆì–´ë¡œì˜ ëª¨í—˜ - Simple</title>
    <style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            text-align: center;
        }
        canvas { 
            border: 2px solid #333; 
            background: #87CEEB;
            display: block;
            margin: 0 auto;
        }
        #instructions {
            margin-top: 10px;
            font-size: 14px;
            color: #555;
        }
        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">ì ìˆ˜: 0</div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="instructions">
            â† â†’ ì´ë™ | ìŠ¤í˜ì´ìŠ¤: ì í”„ | Z: ë°”ë‚˜ë‚˜ ë˜ì§€ê¸° | R: ì¬ì‹œì‘
        </div>
    </div>

    <script>
        // ğŸ® ê²Œì„ ê¸°ë³¸ ì„¤ì •
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        // ğŸ¯ ê²Œì„ ìƒíƒœ
        let gameState = {
            score: 0,
            gameOver: false,
            frameCount: 0
        };

        // ğŸµ ì£¼ì¸ê³µ
        const hero = {
            x: 100,
            y: 300,
            width: 50,
            height: 50,
            velocityY: 0,
            isJumping: false,
            color: '#8B4513'
        };

        // ğŸŒ ë°”ë‚˜ë‚˜ë“¤
        let bananas = [];

        // ğŸ‘¹ ì ë“¤
        let enemies = [];

        // âŒ¨ï¸ í‚¤ë³´ë“œ ìƒíƒœ
        const keys = {};

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Zí‚¤: ë°”ë‚˜ë‚˜ ë˜ì§€ê¸°
            if ((e.key === 'z' || e.key === 'Z') && !gameState.gameOver) {
                throwBanana();
            }
            
            // Rí‚¤: ì¬ì‹œì‘
            if ((e.key === 'r' || e.key === 'R') && gameState.gameOver) {
                resetGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // ğŸŒ ë°”ë‚˜ë‚˜ ë˜ì§€ê¸°
        function throwBanana() {
            bananas.push({
                x: hero.x + hero.width,
                y: hero.y + hero.height / 2,
                width: 20,
                height: 10,
                speed: 10,
                color: '#FFFF00'
            });
            console.log("ë°”ë‚˜ë‚˜ ë°œì‚¬! ğŸŒ");
        }

        // ğŸ‘¹ ì  ìƒì„±
        function spawnEnemy() {
            enemies.push({
                x: canvas.width,
                y: 300,
                width: 40,
                height: 50,
                speed: -3,
                color: '#FF0000',
                isSlipping: false
            });
        }

        // ğŸ¯ ê²Œì„ ì—…ë°ì´íŠ¸
        function update() {
            if (gameState.gameOver) return;

            gameState.frameCount++;

            // ì£¼ì¸ê³µ ì´ë™
            if (keys['ArrowLeft'] && hero.x > 0) {
                hero.x -= 5;
            }
            if (keys['ArrowRight'] && hero.x < canvas.width - hero.width) {
                hero.x += 5;
            }

            // ì í”„
            if (keys[' '] && !hero.isJumping) {
                hero.velocityY = -15;
                hero.isJumping = true;
            }

            // ì¤‘ë ¥
            hero.velocityY += 0.8;
            hero.y += hero.velocityY;

            // ë°”ë‹¥ ì²´í¬
            if (hero.y > 300) {
                hero.y = 300;
                hero.velocityY = 0;
                hero.isJumping = false;
            }

            // ë°”ë‚˜ë‚˜ ì´ë™
            bananas.forEach((banana, index) => {
                banana.x += banana.speed;
                if (banana.x > canvas.width) {
                    bananas.splice(index, 1);
                }
            });

            // ì  ìƒì„± (3ì´ˆë§ˆë‹¤)
            if (gameState.frameCount % 180 === 0) {
                spawnEnemy();
            }

            // ì  ì´ë™
            enemies.forEach((enemy, index) => {
                if (enemy.isSlipping) {
                    enemy.x += 5;
                } else {
                    enemy.x += enemy.speed;
                }

                if (enemy.x < -enemy.width || enemy.x > canvas.width) {
                    enemies.splice(index, 1);
                }
            });

            // ì¶©ëŒ ì²´í¬
            checkCollisions();
        }

        // ğŸ’¥ ì¶©ëŒ ì²´í¬
        function checkCollisions() {
            // ë°”ë‚˜ë‚˜ì™€ ì  ì¶©ëŒ
            bananas.forEach((banana, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (banana.x < enemy.x + enemy.width &&
                        banana.x + banana.width > enemy.x &&
                        banana.y < enemy.y + enemy.height &&
                        banana.y + banana.height > enemy.y &&
                        !enemy.isSlipping) {
                        
                        enemy.isSlipping = true;
                        enemy.color = '#FFA500';
                        bananas.splice(bIndex, 1);
                        gameState.score += 10;
                        scoreDisplay.textContent = `ì ìˆ˜: ${gameState.score}`;
                        
                        setTimeout(() => {
                            const index = enemies.indexOf(enemy);
                            if (index > -1) enemies.splice(index, 1);
                        }, 1000);
                    }
                });
            });

            // ì£¼ì¸ê³µê³¼ ì  ì¶©ëŒ
            enemies.forEach(enemy => {
                if (!enemy.isSlipping &&
                    hero.x < enemy.x + enemy.width &&
                    hero.x + hero.width > enemy.x &&
                    hero.y < enemy.y + enemy.height &&
                    hero.y + hero.height > enemy.y) {
                    gameState.gameOver = true;
                }
            });
        }

        // ğŸ¨ ê·¸ë¦¬ê¸°
        function draw() {
            // í™”ë©´ ì§€ìš°ê¸°
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ë•… ê·¸ë¦¬ê¸°
            ctx.fillStyle = '#8FBC8F';
            ctx.fillRect(0, 350, canvas.width, 50);

            // ì£¼ì¸ê³µ ê·¸ë¦¬ê¸°
            ctx.fillStyle = hero.color;
            ctx.fillRect(hero.x, hero.y, hero.width, hero.height);
            
            // ì–¼êµ´
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(hero.x + 25, hero.y + 20, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // ëˆˆ
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(hero.x + 20, hero.y + 15, 3, 0, Math.PI * 2);
            ctx.arc(hero.x + 30, hero.y + 15, 3, 0, Math.PI * 2);
            ctx.fill();

            // ë°”ë‚˜ë‚˜ ê·¸ë¦¬ê¸°
            ctx.fillStyle = '#FFFF00';
            bananas.forEach(banana => {
                ctx.fillRect(banana.x, banana.y, banana.width, banana.height);
            });

            // ì  ê·¸ë¦¬ê¸°
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            });

            // ê²Œì„ ì˜¤ë²„ ë©”ì‹œì§€
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '24px Arial';
                ctx.fillText('Rí‚¤ë¥¼ ëˆŒëŸ¬ ì¬ì‹œì‘', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        // ğŸ”„ ê²Œì„ ë¦¬ì…‹
        function resetGame() {
            gameState = {
                score: 0,
                gameOver: false,
                frameCount: 0
            };
            hero.x = 100;
            hero.y = 300;
            hero.velocityY = 0;
            hero.isJumping = false;
            bananas = [];
            enemies = [];
            scoreDisplay.textContent = 'ì ìˆ˜: 0';
        }

        // ğŸ® ê²Œì„ ë£¨í”„
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ì‹œì‘!
        gameLoop();
        console.log("ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ®");
    </script>
</body>
</html>